% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootstrap.trendfilter.R
\name{bootstrap.trendfilter}
\alias{bootstrap.trendfilter}
\title{Optimize the trend filtering hyperparameter with respect to Stein's unbiased 
risk estimate}
\usage{
bootstrap.trendfilter(
  x,
  y,
  sigma = NULL,
  lambda.min,
  k = 2,
  x.eval.grid = x,
  bootstrap.method = "nonparametric",
  alpha = 0.05,
  B = 1000,
  full.ensemble = FALSE,
  max_iter = 250,
  obj_tol = 1e-07,
  mc.cores = parallel::detectCores() - 2
)
}
\arguments{
\item{x}{A vector of the observed inputs. If \code{NULL}, then we assume
unit spacing.}

\item{y}{A vector of the observed outputs.}

\item{sigma}{A vector of measurement standard errors for the observed outputs.}

\item{lambda.min}{The optimally-tuned trend filtering hyperparameter, e.g. by 
minimizing SURE (see SURE.trendfilter) or cross validation.}

\item{k}{The degree of the trend filtering estimator. Defaults to \code{k=2}
(quadratic trend filtering).}

\item{x.eval.grid}{Input evaluation grid. Defaults to the observed inputs.}

\item{bootstrap.method}{Bootstrap method to be implemented. See description 
for suggested use. Defaults to "nonparametric".}

\item{alpha}{Specifies the width of the 1-alpha pointwise confidence bands.}

\item{B}{The number of boostrap samples used to compute the confidence bands.}

\item{full.ensemble}{Return the full bootstrap ensemble as an (n x B) matrix.
Defaults to \code{FALSE}.}

\item{max_iter}{Maximum iterations allowed for the trend filtering 
ADMM optimization 
[\href{http://www.stat.cmu.edu/~ryantibs/papers/fasttf.pdf}{Ramdas & Tibshirani (2015)}]. 
Consider increasing this if the trend filtering estimate does not appear to 
have fully converged to a reasonable estimate of the signal.}

\item{obj_tol}{The tolerance used in the ADMM optimization stopping criterion; 
when the relative change in the objective function is less than this value, 
the algorithm terminates.}

\item{mc.cores}{Multi-core computing (for speedups): The number of cores to use.
Defaults to the number detected on the machine minus 2.}
}
\value{
A list with the following elements:
\item{bootstrap.lower.perc.intervals}{Vector of lower bounds for the 1-alpha pointwise confidence band.}
\item{bootstrap.upper.perc.intervals}{Vector of upper bounds for the 1-alpha pointwise confidence band.}
\item{tf.boot.ensemble}{(Optional) The full bootstrap ensemble as an (n x B) matrix.}
}
\description{
\code{bootstrap.trendfilter} implements one of three bootstrap 
algorithms to obtain variability bands to accompany an optimized trend
filtering point estimate. The bootstrap method should generally be chosen 
according to the following criteria: \cr \cr
S1. The inputs are irregularly 
sampled –> \code{bootstrap.method = "nonparametric"} \cr \cr
S2. The inputs are regularly 
sampled and the noise distribution is known –> \code{bootstrap.method = "parametric"} \cr \cr
S3. The inputs are regularly sampled and the noise distribution is unknown –> 
\code{bootstrap.method = "wild"} \cr
}
\examples{
install.packages("devtools")
devtools::install_github("statsmaths/glmgen", subdir="R_pkg/glmgen")

# Quasar spectrum example
data(quasar)

# SDSS spectra are equally spaced in log10 wavelength space with a separation of 10e-4
# Reading in a spectrum file and retrieving the piece of the spectrum in the Lyman-alpha
# forest region
log.wavelength.scaled <- quasar.spec$col[[2]] * 1000
flux <- quasar.spec$col[[1]]
wts <- quasar.spec$col[[3]]
lya.rest.wavelength <- 1215.67
inds <- which(( 10 ^ (log.wavelength.scaled / 1000) ) / (2.953 + 1) < lya.rest.wavelength + 40)
log.wavelength.scaled <- log.wavelength.scaled[inds]
flux <- flux[inds]
wts <- wts[inds]

# Compute SURE loss curve and optimal lambda
lambda.grid <- exp(seq(-10,7,length=250))
SURE.out <- SURE.trendfilter(log.wavelength.scaled, flux, wts, lambda.grid)
lambda.opt <- SURE.out$lambda[which.min(SURE.out$SURE.loss)]

# Fit optimized model
fit <- glmgen::trendfilter(log.wavelength.scaled, flux, wts, k = 2, lambda = lambda.opt)

# Plot results
wavelength <- 10 ^ (log.wavelength.scaled / 1000)
plot(wavelength, flux, type = "l")
lines(wavelength, fit$beta, col = "orange", lwd = 2.5)

boot.out <- bootstrap.trendfilter(log.wavelength.scaled, flux, lambda.opt, sigma = sqrt(1/wts),
                                  bootstrap.method = "parametric")
lines(wavelength, boot.out$bootstrap.lower.perc.intervals, col = "orange", lty = 2, lwd = 2)
lines(wavelength, boot.out$bootstrap.upper.perc.intervals, col = "orange", lty = 2, lwd = 2)
legend(x = "topleft", lty = c(1,2), col = "orange", lwd = 2, 
       legend = c("Trend filtering estimate", "95 percent variability band"))
}
\seealso{
\code{\link{bootstrap.trendfilter}}
}
\author{
Collin A. Politsch, \email{collinpolitsch@gmail.com}
}
