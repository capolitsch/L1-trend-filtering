% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootstrap.trendfilter.R
\name{bootstrap.trendfilter}
\alias{bootstrap.trendfilter}
\title{Bootstrap the optimized trend filtering estimator to obtain variability bands}
\usage{
bootstrap.trendfilter(
  obj,
  bootstrap.method = c("nonparametric", "parametric", "wild"),
  alpha = 0.05,
  B = 250L,
  full.ensemble = FALSE,
  prune = TRUE,
  mc.cores = max(c(parallel::detectCores() - 2), 1)
)
}
\arguments{
\item{obj}{An object of class 'SURE.trendfilter' or 'cv.trendfilter'.}

\item{bootstrap.method}{A string specifying the bootstrap method to be used. 
One of \code{c("nonparametric","parametric","wild")}. See Details section 
below for suggested use. Defaults to \code{"nonparametric"}.}

\item{alpha}{Specifies the width of the \code{1-alpha} pointwise variability 
bands. Defaults to \code{alpha = 0.05}.}

\item{B}{The number of bootstrap samples used to estimate the pointwise
variability bands. Defaults to \code{B = 250}.}

\item{full.ensemble}{(logical) If \code{TRUE}, the full trend filtering 
bootstrap ensemble is returned as an \eqn{n x B} matrix. Defaults to 
\code{FALSE}.}

\item{prune}{(logical) If \code{TRUE}, then the trend filtering bootstrap 
ensemble is examined for rare instances in which the optimization has stopped 
at zero knots (most likely erroneously), and removes them from the ensemble. 
Defaults to \code{TRUE}. Do not change this unless you really know what you 
are doing.}

\item{mc.cores}{Multi-core computing (for speedups): The number of cores to
utilize. If 4 or more cores are detected, then the default is to utilize
\code{available.cores - 2}. Else, \code{mc.cores = 1}.}
}
\value{
An object of class 'bootstrap.trendfilter'. This is a list with the 
following elements:
\item{x.eval}{The grid of inputs the trend filtering estimate and variability 
bands were evaluated on.}
\item{tf.estimate}{The trend filtering estimate of the signal, evaluated on 
\code{x.eval}.}
\item{bootstrap.lower.perc.intervals}{Vector of lower bounds for the 1-alpha 
pointwise variability band, evaluated on \code{x.eval}.}
\item{bootstrap.upper.perc.intervals}{Vector of upper bounds for the 1-alpha 
pointwise variability band, evaluated on \code{x.eval}.}
\item{bootstrap.method}{The string specifying the bootstrap method that was
used.}
\item{alpha}{The 'level' of the variability bands, i.e. \code{alpha}
produces a \eqn{100*(1-\alpha)}\% pointwise variability band.}
\item{B}{The number of bootstrap samples used to estimate the pointwise
variability bands.}
\item{tf.bootstrap.ensemble}{(Optional) The full trend filtering bootstrap 
ensemble as an \eqn{n x B} matrix. If \code{full.ensemble = FALSE}, then 
this will return \code{NULL}.}
\item{prune}{(logical) If \code{TRUE}, then the trend filtering bootstrap 
ensemble is examined for rare instances in which the optimization has 
stopped at zero knots (most likely erroneously), and removes them from the 
ensemble.}
\item{n.pruned}{The number of badly-converged bootstrap trend filtering 
estimates pruned from the ensemble.}
\item{x}{The vector of the observed inputs.}
\item{y}{The vector of the observed outputs.}
\item{weights}{A vector of weights for the observed outputs. These are
defined as \code{weights[i] = 1 / sigma[i]^2}, where \code{sigma} is a vector 
of standard errors of the uncertainty in the measured outputs.}
\item{fitted.values}{The trend filtering estimate of the signal, evaluated at
the observed inputs \code{x}.}
\item{residuals}{\code{residuals = y - fitted.values}.}
\item{k}{(Integer) The degree of the trend filtering estimator.}
\item{lambda}{Vector of hyperparameter values tested during validation.}
\item{lambda.min}{Hyperparameter value that minimizes the validation error 
curve.}
\item{df}{Vector of effective degrees of freedom for trend filtering
estimators fit during validation.}
\item{df.min}{The effective degrees of freedom of the optimally-tuned trend 
filtering estimator.}
\item{i.min}{The index of \code{lambda} that minimizes the validation error.}
\item{validation.method}{Either "SURE" or "cv".}
\item{error}{Vector of hyperparameter validation errors, inherited from
\code{obj} (either class 'SURE.trendfilter' or 'cv.trendfilter')}
\item{thinning}{(logical) If \code{TRUE}, then the data are 
preprocessed so that a smaller, better conditioned data set is used for 
fitting.}
\item{max_iter}{Maximum iterations allowed for the trend filtering 
convex optimization 
[\href{http://www.stat.cmu.edu/~ryantibs/papers/fasttf.pdf}{Ramdas & Tibshirani (2015)}]. 
Consider increasing this if the trend filtering estimate does not appear to 
have fully converged to a reasonable estimate of the signal.}
\item{obj_tol}{The tolerance used in the convex optimization stopping 
criterion; when the relative change in the objective function is less than 
this value, the algorithm terminates. Consider decreasing this if the trend 
filtering estimate does not appear to have fully converged to a reasonable 
estimate of the signal.}
}
\description{
\code{bootstrap.trendfilter} implements any of three possible 
bootstrap algorithms to obtain pointwise variability bands with a specified 
certainty to accompany an optimized trend filtering point estimate of a 
signal.
}
\details{
The bootstrap method should generally be chosen according to the 
following criteria: \itemize{
\item The inputs are irregularly sampled -> 
\code{bootstrap.method = "nonparametric"}.
\item The inputs are regularly sampled and the noise distribution is known –> 
\code{bootstrap.method = "parametric"}.
\item The inputs are regularly sampled and the noise distribution is 
unknown –> \code{bootstrap.method = "wild"}.}
See \href{https://academic.oup.com/mnras/article/492/3/4005/5704413}{
Politsch et al. (2020)} for more details.
}
\examples{
#############################################################################
##                    Quasar Lyman-alpha forest example                    ## 
#############################################################################
##  SDSS spectra are equally spaced in log base-10 wavelength space with a ##
##  separation of 1e-4 log-Angstroms. Given the default trend filtering    ##
##  optimization parameters, it is safer to scale up the inputs in such a  ##
##  scenario. For example, here we scale to unit spacing.                  ##
#############################################################################

# Load Lyman-alpha forest spectral observations of an SDSS quasar at redshift 
# z = 2.953

data(quasar_spec)
data(plotting_utilities)


# Run the SURE optimization for a quadratic trend filtering estimator, i.e. 
# k = 2 (default)

lambda.grid <- exp(seq(-10, 5, length = 150))
SURE.obj <- SURE.trendfilter(x = log10.wavelength.scaled, 
                             y = flux, 
                             weights = weights, 
                             lambda = lambda.grid)

                                          
# Extract the optimized trend filtering estimate on a fine equally-spaced
# grid from the 'SURE.trendfilter' output

lambda.min <- SURE.obj$lambda.min
SURE.error <- SURE.obj$error
x.eval <- SURE.obj$x.eval                      
tf.estimate <- SURE.obj$tf.estimate


# Run a parametric bootstrap the optimized trend filtering estimator to 
# obtain uncertainty bands

boot.out <- bootstrap.trendfilter(obj = SURE.obj, bootstrap.method = "parametric")


# Transform back to wavelength space

wavelength <- 10 ^ (log10.wavelength.scaled / scale.factor)
wavelength.eval <- 10 ^ (x.eval / scale.factor)


# Plot the results

par(mfrow = c(2,1), mar = c(5,4,2.5,1) + 0.1)
plot(log(lambda.grid), SURE.error,
     main = "SURE error curve", 
     xlab = "log(lambda)", ylab = "SURE error")
abline(v = log(lambda.min), col = "blue3", lty = 2)
text(x = log(lambda.min), y = par("usr")[4], 
     labels = "optimal hyperparameter", pos = 1, col = "blue3")

plot(wavelength, flux, type = "l", 
     main = "Quasar Lyman-alpha forest", 
     xlab = "Observed wavelength (angstroms)", ylab = "flux")
lines(wavelength.eval, tf.estimate, col = "orange", lwd = 2.5)
polygon(c(wavelength.eval, rev(wavelength.eval)), 
        c(boot.out$bootstrap.lower.perc.intervals, 
        rev(boot.out$bootstrap.upper.perc.intervals)),
        col = transparency("orange", 90), border=NA)
lines(wavelength.eval, boot.out$bootstrap.lower.perc.intervals, 
      col = "orange", lwd = 0.5)
lines(wavelength.eval, boot.out$bootstrap.upper.perc.intervals, 
      col = "orange", lwd = 0.5)
legend(x = "topleft", lwd = c(1,2,8), lty = 1, cex = 0.75,
       col = c("black","orange", transparency("orange", 90)), 
       legend = c("Noisy quasar spectrum",
                  "Trend filtering estimate",
                  "95 percent variability band"))
}
\references{
\enumerate{
\item \href{https://academic.oup.com/mnras/article/492/3/4005/5704413}{
Politsch et al. (2020). Trend filtering – I. A modern statistical tool for 
time-domain astronomy and astronomical spectroscopy} \cr

\item \href{https://academic.oup.com/mnras/article/492/3/4019/5704414}{
Politsch et al. (2020). Trend filtering – II. Denoising astronomical signals 
with varying degrees of smoothness} \cr

\item \href{https://projecteuclid.org/journals/annals-of-statistics/volume-7/issue-1/Bootstrap-Methods-Another-Look-at-the-Jackknife/10.1214/aos/1176344552.full}{
Efron (1979). Bootstrap Methods: Another Look at the Jackknife} \cr

\item \href{https://academic.oup.com/mnras/article/492/3/4019/5704414}{
Efron and Tibshirani (1986). Bootstrap Methods for Standard Errors, 
Confidence Intervals, and Other Measures of Statistical Accuracy} \cr

\item \href{https://projecteuclid.org/journals/annals-of-statistics/volume-14/issue-4/Jackknife-Bootstrap-and-Other-Resampling-Methods-in-Regression-Analysis/10.1214/aos/1176350142.full}{
Wu (1986). Jackknife, Bootstrap and Other Resampling Methods in Regression 
Analysis} \cr
}
}
\seealso{
\code{\link{SURE.trendfilter}}, \code{\link{cv.trendfilter}}
}
\author{
Collin A. Politsch, \email{collinpolitsch@gmail.com}
}
